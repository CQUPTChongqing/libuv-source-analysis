<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>signal</title>
  <meta name="description" content="The target of the design:  Asynchronously call signal processing function.  In the loop thread call signal processing function.">

  <link rel="stylesheet" href="/libuv-source-analysis/css/main.css">
  <link rel="canonical" href="http://paulran.github.io/libuv-source-analysis/pages/update/2016/04/25/signal.html">
  <link rel="alternate" type="application/rss+xml" title="从libuv说开来——libuv源码分析" href="http://paulran.github.io/libuv-source-analysis/feed.xml">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/libuv-source-analysis/">从libuv说开来——libuv源码分析</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/libuv-source-analysis/about/">About</a>
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">signal</h1>
    <p class="post-meta"><time datetime="2016-04-25T18:14:10+08:00" itemprop="datePublished">Apr 25, 2016</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <h1 id="the-target-of-the-design">The target of the design:</h1>
<ul>
  <li>Asynchronously call signal processing function.</li>
  <li>In the loop thread call signal processing function.</li>
</ul>

<h1 id="struct-uvsignalt">struct uv_signal_t</h1>

<p><img src="/libuv-source-analysis/jpg/uv_signal_t.jpg" alt="" /></p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">uv_signal_t</span><span class="o">*</span> <span class="n">handle</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">signum</span><span class="p">;</span>
<span class="p">}</span> <span class="n">uv__signal_msg_t</span><span class="p">;</span>


<span class="k">struct</span> <span class="n">uv_loop_s</span> <span class="p">{</span>
  <span class="p">...</span> <span class="p">...</span>
  <span class="cm">/* a pipe, signal_pipefd[0] refers to the read end of the pipe,
   * signal_pipefd[1] refers to the write end of the pipe. 
   * uv__io_poll watches the read end, while signal action uses the 
   * write end. When catching a signal, write a uv__signal_msg_t to 
   * the write end. 
   */</span>
  <span class="kt">int</span> <span class="n">signal_pipefd</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> 
  <span class="n">uv__io_t</span> <span class="n">signal_io_watcher</span><span class="p">;</span>
  <span class="p">...</span> <span class="p">...</span>
<span class="p">};</span>
</code></pre>
</div>

<h1 id="interface">Interface</h1>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">UV_EXTERN</span> <span class="kt">int</span> <span class="n">uv_signal_init</span><span class="p">(</span><span class="n">uv_loop_t</span><span class="o">*</span> <span class="n">loop</span><span class="p">,</span> <span class="n">uv_signal_t</span><span class="o">*</span> <span class="n">handle</span><span class="p">);</span>
<span class="n">UV_EXTERN</span> <span class="kt">int</span> <span class="n">uv_signal_start</span><span class="p">(</span><span class="n">uv_signal_t</span><span class="o">*</span> <span class="n">handle</span><span class="p">,</span>
                              <span class="n">uv_signal_cb</span> <span class="n">signal_cb</span><span class="p">,</span>
                              <span class="kt">int</span> <span class="n">signum</span><span class="p">);</span>
<span class="n">UV_EXTERN</span> <span class="kt">int</span> <span class="n">uv_signal_stop</span><span class="p">(</span><span class="n">uv_signal_t</span><span class="o">*</span> <span class="n">handle</span><span class="p">);</span>

<span class="cm">/* Use kill(), killpg() or raise() to actively raise a signal. */</span>
</code></pre>
</div>

<h1 id="flow">Flow</h1>

<h2 id="set-the-action-for-signal-signum">1. set the action for signal signum</h2>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">uv__signal_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">signum</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">uv__signal_msg_t</span> <span class="n">msg</span><span class="p">;</span>
  <span class="n">uv_signal_t</span><span class="o">*</span> <span class="n">handle</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">saved_errno</span><span class="p">;</span>

  <span class="n">saved_errno</span> <span class="o">=</span> <span class="n">errno</span><span class="p">;</span>
  <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">msg</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">uv__signal_lock</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">errno</span> <span class="o">=</span> <span class="n">saved_errno</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="cm">/* Traversing the red-black tree. */</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">handle</span> <span class="o">=</span> <span class="n">uv__signal_first_handle</span><span class="p">(</span><span class="n">signum</span><span class="p">);</span>
       <span class="n">handle</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">signum</span> <span class="o">==</span> <span class="n">signum</span><span class="p">;</span>
       <span class="n">handle</span> <span class="o">=</span> <span class="n">RB_NEXT</span><span class="p">(</span><span class="n">uv__signal_tree_s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uv__signal_tree</span><span class="p">,</span> <span class="n">handle</span><span class="p">))</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

    <span class="n">msg</span><span class="p">.</span><span class="n">signum</span> <span class="o">=</span> <span class="n">signum</span><span class="p">;</span>
    <span class="n">msg</span><span class="p">.</span><span class="n">handle</span> <span class="o">=</span> <span class="n">handle</span><span class="p">;</span>

    <span class="cm">/* write() should be atomic for small data chunks, so the entire message
     * should be written at once. In theory the pipe could become full, in
     * which case the user is out of luck.
     */</span>
    <span class="k">do</span> <span class="p">{</span>
      <span class="n">r</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">handle</span><span class="o">-&gt;</span><span class="n">loop</span><span class="o">-&gt;</span><span class="n">signal_pipefd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">msg</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">errno</span> <span class="o">==</span> <span class="n">EINTR</span><span class="p">);</span>

    <span class="n">assert</span><span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="k">sizeof</span> <span class="n">msg</span> <span class="o">||</span>
           <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EAGAIN</span> <span class="o">||</span> <span class="n">errno</span> <span class="o">==</span> <span class="n">EWOULDBLOCK</span><span class="p">)));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">handle</span><span class="o">-&gt;</span><span class="n">caught_signals</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">uv__signal_unlock</span><span class="p">();</span>
  <span class="n">errno</span> <span class="o">=</span> <span class="n">saved_errno</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">uv__signal_register_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">signum</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* When this function is called, the signal lock must be held. */</span>
  <span class="k">struct</span> <span class="n">sigaction</span> <span class="n">sa</span><span class="p">;</span>

  <span class="cm">/* XXX use a separate signal stack? */</span>
  <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sa</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sa</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">sigfillset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sa</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">))</span>
    <span class="n">abort</span><span class="p">();</span>
  <span class="n">sa</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="n">uv__signal_handler</span><span class="p">;</span>

  <span class="cm">/* XXX save old action so we can restore it later on? */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">sigaction</span><span class="p">(</span><span class="n">signum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sa</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">errno</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<h2 id="set-the-callback-for-signal-io-fd">2. set the callback for signal I/O fd</h2>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">uv__io_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loop</span><span class="o">-&gt;</span><span class="n">signal_io_watcher</span><span class="p">,</span> <span class="n">uv__signal_event</span><span class="p">,</span> <span class="n">loop</span><span class="o">-&gt;</span><span class="n">signal_pipefd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">uv__io_start</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">loop</span><span class="o">-&gt;</span><span class="n">signal_io_watcher</span><span class="p">,</span> <span class="n">UV__POLLIN</span><span class="p">);</span>
</code></pre>
</div>

<h2 id="call-the-callback-of-signal-io-fd">3. call the callback of signal I/O fd</h2>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">uv__signal_event</span><span class="p">(</span><span class="n">uv_loop_t</span><span class="o">*</span> <span class="n">loop</span><span class="p">,</span>
                             <span class="n">uv__io_t</span><span class="o">*</span> <span class="n">w</span><span class="p">,</span>
                             <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">events</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">uv__signal_msg_t</span><span class="o">*</span> <span class="n">msg</span><span class="p">;</span>
  <span class="n">uv_signal_t</span><span class="o">*</span> <span class="n">handle</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">uv__signal_msg_t</span><span class="p">)</span> <span class="o">*</span> <span class="mi">32</span><span class="p">];</span>
  <span class="kt">size_t</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

  <span class="n">bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">do</span> <span class="p">{</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">loop</span><span class="o">-&gt;</span><span class="n">signal_pipefd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">bytes</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">-</span> <span class="n">bytes</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">errno</span> <span class="o">==</span> <span class="n">EINTR</span><span class="p">)</span>
      <span class="k">continue</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EAGAIN</span> <span class="o">||</span> <span class="n">errno</span> <span class="o">==</span> <span class="n">EWOULDBLOCK</span><span class="p">))</span> <span class="p">{</span>
      <span class="cm">/* If there are bytes in the buffer already (which really is extremely
       * unlikely if possible at all) we can't exit the function here. We'll
       * spin until more bytes are read instead.
       */</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">continue</span><span class="p">;</span>

      <span class="cm">/* Otherwise, there was nothing there. */</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Other errors really should never happen. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">abort</span><span class="p">();</span>

    <span class="n">bytes</span> <span class="o">+=</span> <span class="n">r</span><span class="p">;</span>

    <span class="cm">/* `end` is rounded down to a multiple of sizeof(uv__signal_msg_t). */</span>
    <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uv__signal_msg_t</span><span class="p">))</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uv__signal_msg_t</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">uv__signal_msg_t</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="n">uv__signal_msg_t</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
      <span class="n">handle</span> <span class="o">=</span> <span class="n">msg</span><span class="o">-&gt;</span><span class="n">handle</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="o">-&gt;</span><span class="n">signum</span> <span class="o">==</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">signum</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">handle</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UV_CLOSING</span><span class="p">));</span>
        <span class="n">handle</span><span class="o">-&gt;</span><span class="n">signal_cb</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">signum</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="n">handle</span><span class="o">-&gt;</span><span class="n">dispatched_signals</span><span class="o">++</span><span class="p">;</span>

      <span class="cm">/* If uv_close was called while there were caught signals that were not
       * yet dispatched, the uv__finish_close was deferred. Make close pending
       * now if this has happened.
       */</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">handle</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UV_CLOSING</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
          <span class="p">(</span><span class="n">handle</span><span class="o">-&gt;</span><span class="n">caught_signals</span> <span class="o">==</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">dispatched_signals</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">uv__make_close_pending</span><span class="p">((</span><span class="n">uv_handle_t</span><span class="o">*</span><span class="p">)</span> <span class="n">handle</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">bytes</span> <span class="o">-=</span> <span class="n">end</span><span class="p">;</span>

    <span class="cm">/* If there are any "partial" messages left, move them to the start of the
     * the buffer, and spin. This should not happen.
     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bytes</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">memmove</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">end</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">end</span> <span class="o">==</span> <span class="k">sizeof</span> <span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<h1 id="reference">Reference</h1>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cm">/* Send signal SIG to process number PID.  If PID is zero,
   send SIG to all processes in the current process's process group.
   If PID is &lt; -1, send SIG to all processes in process group - PID.  */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">kill</span> <span class="p">(</span><span class="n">__pid_t</span> <span class="n">__pid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__sig</span><span class="p">)</span> <span class="n">__THROW</span><span class="p">;</span>

<span class="cm">/* Send SIG to all processes in process group PGRP.
   If PGRP is zero, send SIG to all processes in
   the current process's process group.  */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">killpg</span> <span class="p">(</span><span class="n">__pid_t</span> <span class="n">__pgrp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__sig</span><span class="p">)</span> <span class="n">__THROW</span><span class="p">;</span>

<span class="cm">/* Raise signal SIG, i.e., send SIG to yourself.  */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">raise</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__sig</span><span class="p">)</span> <span class="n">__THROW</span><span class="p">;</span>

<span class="cm">/* Set all signals in SET.  */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sigfillset</span> <span class="p">(</span><span class="n">sigset_t</span> <span class="o">*</span><span class="n">__set</span><span class="p">)</span> <span class="n">__THROW</span> <span class="n">__nonnull</span> <span class="p">((</span><span class="mi">1</span><span class="p">));</span>

<span class="cm">/* Modify the signal mask for the calling thread.  The arguments have
   the same meaning as for sigprocmask(2). */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pthread_sigmask</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__how</span><span class="p">,</span>
          <span class="n">__const</span> <span class="n">__sigset_t</span> <span class="o">*</span><span class="kr">__restrict</span> <span class="n">__newmask</span><span class="p">,</span>
          <span class="n">__sigset_t</span> <span class="o">*</span><span class="kr">__restrict</span> <span class="n">__oldmask</span><span class="p">)</span><span class="n">__THROW</span><span class="p">;</span>

<span class="cm">/* Send signal SIGNO to the given thread. */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">pthread_kill</span> <span class="p">(</span><span class="n">pthread_t</span> <span class="n">__threadid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__signo</span><span class="p">)</span> <span class="n">__THROW</span><span class="p">;</span>

<span class="cm">/* Get and/or set the action for signal SIG.  */</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="n">sigaction</span> <span class="p">(</span><span class="kt">int</span> <span class="n">__sig</span><span class="p">,</span> <span class="n">__const</span> <span class="k">struct</span> <span class="n">sigaction</span> <span class="o">*</span><span class="kr">__restrict</span> <span class="n">__act</span><span class="p">,</span>
          <span class="k">struct</span> <span class="n">sigaction</span> <span class="o">*</span><span class="kr">__restrict</span> <span class="n">__oact</span><span class="p">)</span> <span class="n">__THROW</span><span class="p">;</span>
</code></pre>
</div>


  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">从libuv说开来——libuv源码分析</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>从libuv说开来——libuv源码分析</li>
          <li><a href="mailto:xiaomaoln@gmail.com">xiaomaoln@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/paulran"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">paulran</span></a>

          </li>
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>协作共享
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
